---
layout: post
title:      "Airport Finder, a Ruby CLI"
date:       2019-07-13 05:09:32 +0000
permalink:  airport_finder_a_ruby_cli
---


## Background

The first major project assigned to my cohort at Flatiron School was a Ruby CLI.  The program needed to provide a Command Line Interface (CLI) that would guide the user, taking input as needed and display content requested by the user.  The content was to be scraped from a website, broken into groups of lists and detailed information as needed and requested.  To satisfy this project, I choose to write an airport finder.

## Overview
My airport finder CLI would take in a US location, based on either city & state OR zip code, and a search radius.  It  would pass this info to a  website, http://www.airnav.com/, then scrape their returned data to present to the user.  First, from the returned airports, it would list up to the nearest 50 airports given the search criteria.  The user then has the  option to view details related to each airport from the list.  By entering the number of the desired airport, the user would then be presented with a list of the available categories of details, as well as an option to view the airport on a navigation chart, return to the airport list, or return to the main menu.

## The CLI
Writing the CLI was an interesting experience.  Getting clean, readable, logical code written out just wasn't happening as I reasoned through the flow I wanted the user to experience and as I attempted to get the display to look right.  If all I wanted to do was  dump the data from  the  site to the command line, no problem!  But getting things to flow in a way that felt natural and display the results and options in meaningful and pleasing format competed  with just getting the program to simply work.  As with much of this project, the nature became a stream of consciousness coding session, followed by copious refactoring.  Earlier in the project, the refactoring led to near desperation as inevitably everything would break.  The  best part to this was that my debugging skills grew leaps and bounds.  Ah, there's a problem in a file I haven't touched in three days suddenly?  I must have forgotten the 'end' for an 'if' somewhere.  Method does not  exist for NilClass?  I left off the index for an array or  the '.text' on a Nokogiri element.  What would take the better part of my pomodoro programming session soon was solved in a couple minutes.

## Scraping
I chose the site I used  for two reasons: First, I used the site  a lot in a past life, so I was familiar with it (not in a programming way).  Second, after a quick glance at its HTML in the dev tools window it seemed a good candidate.  What I failed to notice in the little window in Chrome, was that although the site seemed nicely arranged, their irregular nesting practices and almost complete lack of use of any classes or  ids made getting to the  data I needed after scraping an absolute nightmare.  Aha!  So the data I need is in the second <table> deep following an <h3>.  Got it!  Oh, except for this section where it follows an <h4> instead?  OK, no prob.  Hmmm..... This section actually seems to be three <table>s deep and every other <td> is just non-ASCII characters.  And so  on and so on.  While the data was still accessible, a nice, neat programmatic approach to getting at all of  it became a web special exceptions conditionals.  Moral of the story, don't let sunk costs dissuade you from changing directions when you really should.  But if you do, just be sure to learn something along the ride.

## Classes
While there was also a good deal of refactoring at the end of this portion (read: every single variable and method), this seemed to be the most straight  forward part of the project.  When the user entered the search criteria, the CLI would call the .new method of the Search class.  The new instance would take care of calling the scraper and returning the results.  With this info, the CLI would then call on the Airport class to make a new instance and parse the data into meaningful groups for the CLI to display.  The Airport instances would have runway objects and the runway objects would have airport objects.  When a new runway object is instantiated, it would add itself to its airport, and the airport would be able to display the runways variables values by calling its methods.  The logic and relationships here seemed quite natural.  The proper use of patterns and ensuring good naming use of object oriented programming paradigms is  where the bulk of refactoring took place.

## Git
This project was also a great dive into git version control and github.  I've used both, but I've never gone much deeper than creating a new repo, committing, and pushing.  A little bit of branching here and there, but never with a real understanding of the why/how.  This project was a solo gig.  So there is  still MUCH of git I haven't even seen.  I've only scraped the surface.  However, I do have a better appreciation for those aspect of git I used in this project.  Watching my code change as I checked out another branch when I switched between features was great.  Even better was knowing that if I really botched this part, all the rest that was tested and merged, would be there safe and sound, waiting for me when I needed it.

## Overall Experience
The labs up to this point have been good, but they all seemed incomplete.  Having  tests written out that almost tell you what to do next or what you've done wrong is great to learn, but it never really feels like YOU are the one doing the work.  This project hadn't that shortfall in the least.  Every bit of the pride and frustration was solely mine.  The initial choices, mine.  Decisions on how to solve the bugs I encountered, mine.  Blame when this damn thing should work so why isn't it, MINE!  It really poked holes in my confidence at times, but showed me where the gaps in my understanding were and where I need to focus my learning efforts in the future.  Even as we shift out of Ruby, I can use this experience to improve my thinking and approach to solving programming problems.
