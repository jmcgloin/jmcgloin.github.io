---
layout: post
title:      "Authentication Based Rendering and Routing"
date:       2020-04-02 04:12:23 -0400
permalink:  authentication_based_rendering_and_routing
---


For my final project for Flatiron School's bootcamp I created an app that uses a Rails API serving data to a React front end.  Using user authentication on the server ensured that user wouldn't be shown data that didn't belong to them, but how about just accessing pages that a user isn't authorized to?  It isn't enough to just return an empty page or a "you're not allowed to be here" message.  I  achieved a better flow and user experience by employing protected routes and making use of redirecting.  This meant user wouldn't make it to the pages to begin with, but instead be sent to a page appropriate for them or a publicly accessible page.  Here are some ways to achieve this.

## JWT

Firstly, the method I used to ensure the front and back both knew  user was JSON Web Tokens (JWT).  JWT is an internet standard that allows two ends to represent claims securely.  Essentially, data is encoded in string that includes the payload (e.g. session state or non-sensitive user information) and then appended with a header and signature.  The header includes the encoding and token type.  The signature is calculated using the header, payload and a secret.  The secrete (usually generated by  the server) ensures the data hasn't been tampered with.  Encoding the payload and header data (and decoding, for that matter) is possible, but without know the secret, spoofing the signature is far more difficult and thereby allows for the verification of the header and payload data.

In practical terms, the user makes a request to the server to be authenticated.  The server authenticates and responds to the user with the token.  Then, the client holds that token and makes subsequent requests to the server using it to prove identity.  Depending how these tokens are used and stored, they are susceptible to various attacks.  This topic is both far advanced of my level of  understanding and too lengthy to be included here.  From here on out, I shall focus on only the React implementation and make certain assumptions that security concerns are being appropriately handled.

## Which Pocket

At this point, our user has received the authorization token in the response from the server and the client is now holding that token.  There are several options for where to hold the token for future requests.  The two primary options are local storage (or session storage) and cookies.  Again, this gets outside the scope of this post, but there are pros and cons to each.  The prevailing wisdom is to store the token in special cookies that only allow it to be sent for HTTP requests.  This prevents it from being tampered with or even accessed except when included in a request.  Local storage, on the other hand, is easily available to any application running JavaScript.  Proper user of the JWT can reduce some risk of storing in local storage, but the risk is still there.

## Client authorization

Depending on where you store your token, there are a few options available to check on the front end whether the user should have access to certain resources.  The very same thing that makes local storage unsecured makes it very easy to work with.  You can at any point in your application just check with `localStorage.getItem('tokenName')` to see if the token exists.  Additionally, saving a flag that the user has been authenticated (e.g. during the authentication action) allows for easy verification of  authorization and makes updating the authorization status easy.

For example, 
```
class Auth {
  constructor() {
    this.authenticated = false;
  }

  loginUser(callback) {
    this.authenticated = true;
    callback()
  }

  logoutUser(callback) {
    this.authenticated = false;
    callback();
  }

  isAuthenticated() {
    return this.authenticated;
  }
}

export default new Auth();
```
By importing this into the authorization actions, a call to `auth.loginUser` can be made to update the authenticated status.  Then upon logging out, another call to set `authentication` to `false`.  In addition, the server should sill decide which data to return in response to requests.  If the server responds that the user is not  authorized, the client can make calls to update the authentication/authorized status.

## Protected Routes

One means to actually control access to certain pages or components is to use protected routes.  You create a component that renders content for authorized users and redirects the unauthorized.  An example, taken from a FreeCodeCamp post ( [ the video for which can be found here](https://www.youtube.com/watch?v=Y0-qdp-XBJg) ) follows.

```
import React from "react";
import { Route, Redirect } from "react-router-dom";
import auth from "./auth";

export const ProtectedRoute = ({
  component: Component,
  ...rest
}) => {
  return (
    <Route
      {...rest}
      render={props => {
        if (auth.isAuthenticated()) {
          return <Component {...props} />;
        } else {
          return (
            <Redirect
              to={
							    {
                    pathname: "/",
                    state: { from: props.location }
							    }
							}
            />
          );
        }
      }}
    />
  );
};
```
This component can be used just like the React Route component when setting up the Router.  You just add the path and component to render for authorized users and replace the `pathname` field with the destination for the unauthorized.  Like this: 
```
<ProtectedRoute exact path="/admins" component={RestrictedComponent} />
```
With the redirect to `pathname: "/users"` that routes to a unrestricted component (or a component that requires different authorization).

## Conditional rendering

This is a very useful tool.  I doesn't only apply to authorization.  For example, if you want to show a button that changes text when clicked, you could use: 
```
renderButton =  () => {
		return this.state.buttonStatus ? 
		    <button type="button" onClick={ this.handleClick } >On</button> : 
				<button type="button" onClick={ this.handleClick } >Off</button>
}
```
This is a very simple example of two buttons, one of which will be rendered based on a flag stored in local state.  If, for example, the flag is true, the "On" text will be rendered on the button.  Otherwise the "Off" text will.

This example can be modified to allow for conditional rendering for a variety of situations including authorization.  If we use the Auth class from above, we could have a button used for logging in when not logged in, or logging out when otherwise.  Like this:
```
import auth from "./auth";
[...]
renderButton = () => {
    return auth.isAuthenticated() ? 
		    <button type="button" onClick={ this.loginUser } >Hello</button> : 
				<button type="button" onClick={ this.logoutUser } >Goodbye</button>
}
```
Then just call `renderButton` where the button is required and the text and onClick callback will be handled based on the authentication.

If you choose to use local storage to hold the token, the call to auth's isAuthenticated can be replaced with `localStorage.getItem('tokenName')`.

Another common scenario for conditional rendering is when something should only be rendered conditionally (vs. choosing between which option to render).  For example:
```
renderAward = () => {
    return this.state.award && <Award />
}
```
Which will only return the Award component if the award state is truthy.  One thing to be careful of is that if the first part is falsey, it will be returned.  There for, be sure where its being returned can handle what specifically is returned.  Sometimes any falsey value will do, sometimes it may have to be `null` sometimes `null` isn't permitted.

While this isn't a direct guide on exactly how to accomplish what I've done in my project, I  hop this gives some guidance and ideas on how to combine the various strategies available to build your app with authentication based conditional rendering and routing.
